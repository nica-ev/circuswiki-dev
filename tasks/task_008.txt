# Task ID: 8
# Title: Implement TranslationService with DeepL integration
# Status: done
# Dependencies: 2
# Priority: high
# Description: Create a service to send text to the DeepL API for translation.
# Details:
Implement a TranslationService class that sends extracted text to the DeepL API. Use the API key from configuration. Handle API response parsing, error handling, and retries. Include support for multiple target languages as specified in configuration.

# Test Strategy:
Create mock API responses to test successful translations and error handling. If possible, test with actual DeepL API using small text samples. Verify correct handling of multiple target languages.

# Subtasks:
## 1. Create TranslationService class structure and configuration [done]
### Dependencies: None
### Description: Set up the basic class structure for TranslationService and implement configuration loading for the DeepL API key and supported languages
### Details:
Create a TranslationService class with constructor that loads configuration. Implement methods to retrieve the API key from configuration and load the list of supported target languages. Add appropriate interfaces and dependency injection support. Include configuration validation to ensure required settings are present.

<info added on 2025-05-04T17:38:53.434Z>
## Implementation Details

### TranslationService Class Structure
```python
from typing import List, Dict, Optional
import logging
from src.config.config_loader import ConfigLoader

class TranslationService:
    def __init__(self, config_loader: ConfigLoader):
        self.logger = logging.getLogger(__name__)
        self.config_loader = config_loader
        
        # Load API provider configuration
        self.api_provider = self.config_loader.settings.get('API_PROVIDER')
        if not self.api_provider:
            raise ValueError("API_PROVIDER not specified in configuration")
        
        # Load API key based on provider
        env_key_name = f"{self.api_provider.upper()}_API_KEY"
        self.api_key = self.config_loader.env_vars.get(env_key_name)
        if not self.api_key:
            raise ValueError(f"Missing API key for {self.api_provider}. Set {env_key_name} environment variable")
        
        # Load and validate target languages
        self.target_languages = self.config_loader.settings.get('TARGET_LANGUAGES_LIST', [])
        if not self.target_languages or not isinstance(self.target_languages, list):
            raise ValueError("TARGET_LANGUAGES_LIST must be a non-empty list")
            
        self.logger.info(f"TranslationService initialized with {self.api_provider} provider")
        self.logger.debug(f"Supported target languages: {', '.join(self.target_languages)}")
    
    def get_supported_languages(self) -> List[str]:
        """Return the list of supported target languages"""
        return self.target_languages.copy()
    
    def is_language_supported(self, language_code: str) -> bool:
        """Check if a specific language code is supported"""
        return language_code in self.target_languages
    
    def translate_text(self, text: str, target_language: str, source_language: Optional[str] = None) -> str:
        """Translate a single text string to the target language"""
        raise NotImplementedError("Method will be implemented in the next iteration")
    
    def translate_batch(self, texts: List[str], target_language: str, source_language: Optional[str] = None) -> List[str]:
        """Translate a batch of text strings to the target language"""
        raise NotImplementedError("Method will be implemented in the next iteration")
```

### Configuration Example
```python
# Example configuration in settings.yaml
API_PROVIDER: "DeepL"
TARGET_LANGUAGES_LIST:
  - "DE"  # German
  - "FR"  # French
  - "ES"  # Spanish
  - "IT"  # Italian
  - "JA"  # Japanese
```

### Test Cases
```python
def test_get_supported_languages():
    """Test that get_supported_languages returns a copy of the languages list"""
    mock_config = MagicMock()
    mock_config.settings = {'API_PROVIDER': 'DeepL', 'TARGET_LANGUAGES_LIST': ['DE', 'FR', 'ES']}
    mock_config.env_vars = {'DEEPL_API_KEY': 'fake-key'}
    
    service = TranslationService(mock_config)
    languages = service.get_supported_languages()
    
    # Verify it returns the correct languages
    assert languages == ['DE', 'FR', 'ES']
    
    # Verify it's a copy (modifying the returned list shouldn't affect the original)
    languages.append('IT')
    assert service.get_supported_languages() == ['DE', 'FR', 'ES']

def test_is_language_supported():
    """Test that is_language_supported correctly identifies supported languages"""
    mock_config = MagicMock()
    mock_config.settings = {'API_PROVIDER': 'DeepL', 'TARGET_LANGUAGES_LIST': ['DE', 'FR', 'ES']}
    mock_config.env_vars = {'DEEPL_API_KEY': 'fake-key'}
    
    service = TranslationService(mock_config)
    
    assert service.is_language_supported('DE') is True
    assert service.is_language_supported('FR') is True
    assert service.is_language_supported('IT') is False
    assert service.is_language_supported('') is False
```

### Dependency Injection Setup
For dependency injection, register the service in your DI container:

```python
# In your dependency injection setup file
from dependency_injector import containers, providers
from src.config.config_loader import ConfigLoader
from src.services.translation_service import TranslationService

class Container(containers.DeclarativeContainer):
    config = providers.Singleton(ConfigLoader)
    translation_service = providers.Singleton(
        TranslationService,
        config_loader=config
    )
```
</info added on 2025-05-04T17:38:53.434Z>

## 2. Implement core translation method with DeepL API integration [done]
### Dependencies: 8.1
### Description: Create the primary translation method that sends text to the DeepL API and processes the basic response
### Details:
Implement a TranslateText method that takes source text and target language code as parameters. Create the HTTP client to communicate with DeepL API. Build the request with proper authentication headers using the API key. Send the request to the DeepL translation endpoint and parse the basic successful response. Return the translated text.

<info added on 2025-05-04T17:42:14.630Z>
## Implementation Plan (Iteration 1)

1.  **Dependency Check**: Ensure `httpx` is in `translation-py/requirements.txt`. Add if missing.
2.  **Modify `TranslationService` (`translation-py/src/services/translation_service.py`)**:
    *   Import `httpx`.
    *   Import `Optional` from `typing` if not already present.
    *   Implement `_initialize_http_client`:
        *   If `self._http_client` is None, create `self._http_client = httpx.Client(timeout=30.0)`.
    *   Implement `translate_text`:
        *   Call `self._validate_target_language(target_language)`.
        *   Handle `self.test_mode` (return simulated translation).
        *   Call `self._initialize_http_client()`.
        *   Define `DEEPL_API_URL` (e.g., `"https://api-free.deepl.com/v2/translate"`).
        *   Prepare `headers = {'Authorization': f'DeepL-Auth-Key {self.api_key}'}`.
        *   Prepare `payload = {'text': text, 'target_lang': target_language}`.
        *   If `source_language` is provided, add it to `payload`.
        *   Wrap the API call in a `try...except httpx.RequestError as e:` block for basic network errors.
        *   Make the call: `response = self._http_client.post(DEEPL_API_URL, headers=headers, data=payload)`.
        *   Check `response.status_code`:
            *   If 200: Parse `response.json()`, extract `['translations'][0]['text']`, and return it.
            *   If not 200: Log the error (status code, response text) and raise `RuntimeError(f"DeepL API Error {response.status_code}: {response.text}")`. (More specific error handling in 8.3).

3.  **Modify Tests (`translation-py/tests/services/test_translation_service.py`)**:
    *   Add `from unittest.mock import patch`.
    *   `test_translate_text_success`:
        *   Use `@patch('httpx.Client')`.
        *   Mock the `post` method of the client instance to return a MagicMock response with `status_code=200` and `.json()` returning `{'translations': [{'text': 'Hallo Welt'}]}`.
        *   Instantiate `TranslationService` with appropriate mock config.
        *   Call `service.translate_text('Hello World', 'DE')`.
        *   Assert the return value is `'Hallo Welt'`. Assert `mock_post.assert_called_once()`.
    *   `test_translate_text_api_error`:
        *   Use `@patch('httpx.Client')`.
        *   Mock `post` to return a response with `status_code=403` and `text='Forbidden'`. 
        *   Use `pytest.raises(RuntimeError, match="DeepL API Error 403")` when calling `service.translate_text`.
    *   `test_translate_text_network_error`:
        *   Use `@patch('httpx.Client')`.
        *   Mock `post` to raise `httpx.RequestError("Network issue")`.
        *   Use `pytest.raises(httpx.RequestError)` when calling `service.translate_text`.
    *   `test_translate_text_respects_test_mode`:
        *   Instantiate service with `TEST_MODE_BOOL=True`.
        *   Use `@patch('httpx.Client')` just to verify it's *not* called.
        *   Call `service.translate_text('Hello', 'DE')`.
        *   Assert the result is the simulated `"[Translated DE] Hello"`.
        *   Assert `mock_client_instance.post.assert_not_called()`.
    *   `test_translate_text_with_source_language`:
        *   Use `@patch('httpx.Client')`.
        *   Mock `post` to return a successful response.
        *   Call `service.translate_text('Bonjour', 'EN', source_language='FR')`.
        *   Assert `mock_post.assert_called_once()` and inspect the `data` argument passed to `post` to ensure `source_lang='FR'` was included.

4.  **Next Steps**: Implement code and run tests.
</info added on 2025-05-04T17:42:14.630Z>

## 3. Add comprehensive error handling for API responses [done]
### Dependencies: 8.2
### Description: Enhance the translation method with proper error handling for various API response scenarios
### Details:
Implement error handling for different HTTP status codes (401 for authentication issues, 429 for rate limiting, etc.). Create custom exception types for different error scenarios. Parse error messages from the DeepL API response. Add logging for errors with appropriate severity levels. Ensure the service provides meaningful error messages to callers.

<info added on 2025-05-04T17:47:59.506Z>
## Implementation Details

### Custom Exception Structure
```python
class TranslationError(Exception):
    """Base exception for all translation-related errors."""
    pass

class TranslationAuthError(TranslationError):
    """Raised when authentication with the translation API fails."""
    pass

class TranslationRateLimitError(TranslationError):
    """Raised when API rate limits are exceeded."""
    def __init__(self, message, retry_after=None):
        super().__init__(message)
        self.retry_after = retry_after  # Store retry-after header value if available

class TranslationAPIError(TranslationError):
    """Raised for general API errors."""
    def __init__(self, message, status_code=None, response_body=None):
        super().__init__(message)
        self.status_code = status_code
        self.response_body = response_body

class TranslationNetworkError(TranslationError):
    """Raised when network issues prevent API communication."""
    pass
```

### Error Response Parsing
```python
def _parse_error_response(response):
    """Extract detailed error information from DeepL API response."""
    try:
        error_data = response.json()
        error_message = error_data.get('message', '')
        error_code = error_data.get('error', {}).get('code', '')
        return f"{error_code}: {error_message}" if error_code else error_message
    except (ValueError, KeyError):
        return response.text
```

### Rate Limit Handling
```python
# Inside the 429 error handling block
retry_after = response.headers.get('Retry-After')
if retry_after:
    logger.warning(f"Rate limit exceeded. Retry after {retry_after} seconds.")
    raise TranslationRateLimitError(
        f"DeepL API rate limit exceeded. Retry after {retry_after} seconds.", 
        retry_after=int(retry_after)
    )
```

### Logging Enhancement
```python
# Configure structured logging
import logging
import json

class JSONFormatter(logging.Formatter):
    def format(self, record):
        log_record = {
            'timestamp': self.formatTime(record),
            'level': record.levelname,
            'message': record.getMessage(),
            'module': record.module
        }
        if hasattr(record, 'status_code'):
            log_record['status_code'] = record.status_code
        if hasattr(record, 'error_type'):
            log_record['error_type'] = record.error_type
        return json.dumps(log_record)

# Usage in error handling:
logger.error("API authentication failed", 
             extra={'status_code': e.response.status_code, 'error_type': 'auth_error'})
```

### Retry Mechanism
```python
def translate_with_retry(text, source_lang, target_lang, max_retries=3, backoff_factor=1.5):
    """Translate text with exponential backoff retry for rate limit errors."""
    retry_count = 0
    while True:
        try:
            return translate_text(text, source_lang, target_lang)
        except TranslationRateLimitError as e:
            retry_count += 1
            if retry_count > max_retries:
                logger.error(f"Max retries ({max_retries}) exceeded for translation request")
                raise
            
            # Use retry-after header if available, otherwise calculate backoff
            wait_time = e.retry_after if e.retry_after else backoff_factor ** retry_count
            logger.info(f"Rate limit hit, retrying in {wait_time} seconds (attempt {retry_count}/{max_retries})")
            time.sleep(wait_time)
        except (TranslationAuthError, TranslationAPIError, TranslationNetworkError):
            # Don't retry these errors
            raise
```
</info added on 2025-05-04T17:47:59.506Z>

<info added on 2025-05-04T17:49:00.439Z>
<info added on 2025-05-05T09:23:12.104Z>
## Implementation Status Report

### Integration with Existing Error Handling System
```python
# In translation_service.py
from app.core.logging import get_logger
from app.core.exceptions import handle_external_service_error

logger = get_logger(__name__)

def translate_text(text, source_lang, target_lang):
    try:
        # Existing translation code...
    except Exception as e:
        # Wrap in our application's standard error handling
        handle_external_service_error(e, service_name="DeepL", 
                                     operation="text translation",
                                     context={"source_lang": source_lang, "target_lang": target_lang})
        raise
```

### HTTP Status Code Mapping
```python
# Complete HTTP status code handling
STATUS_CODE_HANDLERS = {
    400: lambda resp: TranslationAPIError(f"Bad request: {_parse_error_response(resp)}", resp.status_code, resp.text),
    401: lambda resp: TranslationAuthError("Authentication failed: Invalid API key", resp.status_code, resp.text),
    403: lambda resp: TranslationAuthError("Authentication failed: Access forbidden", resp.status_code, resp.text),
    404: lambda resp: TranslationAPIError("Resource not found", resp.status_code, resp.text),
    413: lambda resp: TranslationAPIError("Payload too large", resp.status_code, resp.text),
    414: lambda resp: TranslationAPIError("URI too long", resp.status_code, resp.text),
    429: lambda resp: _handle_rate_limit(resp),
    456: lambda resp: TranslationAPIError("Quota exceeded", resp.status_code, resp.text),
    503: lambda resp: TranslationAPIError("Service unavailable", resp.status_code, resp.text),
}

def _handle_http_error(response):
    """Handle HTTP errors based on status code"""
    handler = STATUS_CODE_HANDLERS.get(
        response.status_code, 
        lambda r: TranslationAPIError(f"Unexpected API error: {_parse_error_response(r)}", r.status_code, r.text)
    )
    return handler(response)
```

### Metrics Collection
```python
# Add metrics collection for error monitoring
from app.core.metrics import increment_counter, record_timing

def translate_text(text, source_lang, target_lang):
    start_time = time.time()
    success = False
    error_type = None
    
    try:
        # Existing translation code...
        success = True
        return result
    except TranslationRateLimitError as e:
        error_type = "rate_limit"
        raise
    except TranslationAuthError as e:
        error_type = "auth"
        raise
    except TranslationAPIError as e:
        error_type = "api"
        raise
    except TranslationNetworkError as e:
        error_type = "network"
        raise
    finally:
        duration = time.time() - start_time
        record_timing("translation_service.request_duration", duration)
        increment_counter("translation_service.requests", 
                         tags={"success": success, 
                              "error_type": error_type or "none",
                              "source_lang": source_lang,
                              "target_lang": target_lang})
```

### Circuit Breaker Pattern
```python
from pybreaker import CircuitBreaker

# Create circuit breaker for translation service
translation_breaker = CircuitBreaker(
    fail_max=5,           # Number of failures before opening circuit
    reset_timeout=60,     # Seconds until attempting to close circuit
    exclude=[TranslationAuthError]  # Don't count auth errors for circuit breaking
)

@translation_breaker
def translate_text(text, source_lang, target_lang):
    # Existing implementation
    pass
```

### Error Response Documentation
```python
# Error response examples for documentation
ERROR_RESPONSE_EXAMPLES = {
    "auth_error": {
        "status_code": 403,
        "error": {
            "message": "Authentication failed",
            "code": "auth_failed"
        }
    },
    "rate_limit": {
        "status_code": 429,
        "error": {
            "message": "Too many requests",
            "code": "too_many_requests"
        },
        "headers": {
            "Retry-After": "30"
        }
    },
    "quota_exceeded": {
        "status_code": 456,
        "error": {
            "message": "Quota exceeded",
            "code": "quota_exceeded"
        }
    }
}
```
</info added on 2025-05-05T09:23:12.104Z>
</info added on 2025-05-04T17:49:00.439Z>

## 4. Implement retry mechanism for transient failures [done]
### Dependencies: 8.3
### Description: Add a retry mechanism to handle temporary failures when communicating with the DeepL API
### Details:
Implement an exponential backoff retry strategy for transient errors (network issues, 5xx responses, etc.). Configure retry count and delay parameters from configuration. Add circuit breaker pattern to prevent overwhelming the API during extended outages. Implement timeout handling. Add detailed logging for retry attempts.

<info added on 2025-05-04T17:52:13.955Z>
# Implementation Plan (Iteration 1)

## Detailed Implementation Notes

### Retry Mechanism Design
- Use a stateless retry approach initially, with plans to add circuit breaker in iteration 2
- Implement exponential backoff with jitter to prevent thundering herd problem:
  ```python
  import random
  wait_time = self.retry_backoff_factor * (2 ** attempt) * (0.8 + 0.4 * random.random())
  ```

### Error Classification
- Create a helper method to classify errors:
  ```python
  def _is_retryable_error(self, exception):
      if isinstance(exception, (TranslationNetworkError, TranslationRateLimitError)):
          return True
      if isinstance(exception, TranslationAPIError) and exception.status_code in self.retry_status_codes:
          return True
      return False
  ```

### Logging Enhancements
- Add structured logging with context:
  ```python
  self.logger.warning(
      "API call failed, will retry",
      extra={
          "attempt": attempt + 1,
          "max_attempts": self.retry_max_attempts,
          "wait_time": wait_time,
          "error_type": type(e).__name__,
          "status_code": getattr(e, "status_code", None)
      }
  )
  ```

### Timeout Handling
- Add request timeout configuration:
  ```yaml
  # In settings.default.yaml
  API_REQUEST_TIMEOUT: 10  # seconds
  ```
- Pass timeout to HTTP client:
  ```python
  response = self._http_client.post(url, headers=headers, json=payload, timeout=self.request_timeout)
  ```

### Testing Edge Cases
- Add test for timeout scenario:
  ```python
  @patch('requests.post', side_effect=requests.exceptions.Timeout("Request timed out"))
  def test_translate_text_handles_timeout(self, mock_post, mock_sleep, ...):
      # Test that timeout is converted to TranslationNetworkError and retried
  ```
- Add test for partial success (some translations fail, others succeed)

### Performance Monitoring
- Add metrics collection for retry attempts:
  ```python
  # Track metrics for monitoring retry performance
  if attempt > 0:
      self.metrics.increment("translation.retry.attempt", tags={"attempt": attempt})
  ```
</info added on 2025-05-04T17:52:13.955Z>

<info added on 2025-05-04T17:54:04.118Z>
## Implementation Log (Iteration 1 - Completion)

- Added retry configuration options (`RETRY_MAX_ATTEMPTS`, `RETRY_BACKOFF_FACTOR`, `RETRY_STATUS_CODES`) to `settings.default.yaml`.
- Updated `ConfigLoader` to load and validate these settings.
- Updated `TranslationService.__init__` to load retry settings from config.
- Added `status_code` attribute to `TranslationAPIError`.
- Implemented private helper method `_make_api_call_with_retry` containing:
    - Loop for `retry_max_attempts`.
    - Core `_http_client.post` call.
    - `try...except` block to catch `HTTPStatusError` and `RequestError`.
    - Instantiation of custom `Translation...Error` exceptions based on caught errors.
    - Check if the caught error is retryable using `_is_retryable_error` helper.
    - Exponential backoff (`time.sleep`) calculation and call for retryable errors.
    - Raising the appropriate error if not retryable or max attempts reached.
- Updated `translate_text` to call `_make_api_call_with_retry`.
- Added new tests in `test_translation_service.py` specifically for retry logic:
    - Test retry success for network, rate limit (429), and server (503) errors.
    - Test failure after max attempts.
    - Test no retry for auth (403) and non-retryable API (400) errors.
    - Used `@patch('time.sleep')` and mock `side_effect` to simulate errors and avoid delays.
- No rule updates needed.
</info added on 2025-05-04T17:54:04.118Z>

## 5. Add batch translation support and language detection [done]
### Dependencies: 8.4
### Description: Extend the service with methods for batch translation and automatic language detection
### Details:
Implement a BatchTranslate method to efficiently translate multiple texts in a single API call. Add support for automatic source language detection using DeepL's detection capabilities. Create methods to validate if a target language is supported. Implement caching for frequently translated content to reduce API calls. Add usage statistics tracking to monitor API consumption.

<info added on 2025-05-04T17:55:28.479Z>
Based on your request, here's additional implementation information for the batch translation support:

## Implementation Details for Batch Translation

### API Payload Structure Considerations

When implementing the `translate_batch` method, pay special attention to the payload structure for DeepL's API:

- DeepL expects multiple text items as repeated parameters rather than a JSON array[2]
- The payload structure using list-of-tuples ensures proper formatting: `[('text', text1), ('text', text2), ...]`
- Maximum batch size should be limited to 50 texts per request to avoid potential API limitations
- Add a `batch_size` parameter with default value of 50 to allow configuration

### Error Handling Enhancements

Implement robust error handling specifically for batch operations:

```python
def _process_batch_response(self, response, texts):
    """Process batch translation response and handle potential errors."""
    try:
        response_data = response.json()
        translations = response_data.get('translations', [])
        
        if len(translations) != len(texts):
            self.logger.error(f"API returned {len(translations)} translations for {len(texts)} input texts")
            raise TranslationError(f"Expected {len(texts)} translations, got {len(translations)}")
            
        return [item['text'] for item in translations]
    except (KeyError, TypeError) as e:
        self.logger.error(f"Failed to parse batch translation response: {str(e)}")
        raise TranslationError(f"Invalid response format: {str(e)}")
```

### Chunking Strategy for Large Batches

To handle large text collections efficiently:

```python
def translate_batch(self, texts, target_language, source_language=None, batch_size=50):
    """Translate multiple texts in efficient batches."""
    if not texts:
        self.logger.warning("Empty texts list provided to translate_batch")
        return []
        
    # Validate languages
    self._validate_target_language(target_language)
    if source_language:
        self._validate_source_language(source_language)
        
    # Handle test mode
    if self.test_mode:
        return [f"[Translated {target_language}] {text}" for text in texts]
    
    # Process in chunks if needed
    results = []
    for i in range(0, len(texts), batch_size):
        chunk = texts[i:i+batch_size]
        chunk_results = self._translate_chunk(chunk, target_language, source_language)
        results.extend(chunk_results)
        
    return results
```

### Performance Optimization

Implement these optimizations for batch translation:

1. **Concurrent Processing**: For very large batches, consider using `asyncio` to make concurrent API calls:

```python
async def translate_batch_async(self, texts, target_language, source_language=None, batch_size=50, max_concurrency=5):
    """Translate large batches with concurrent API calls."""
    if not texts:
        return []
        
    # Split into chunks
    chunks = [texts[i:i+batch_size] for i in range(0, len(texts), batch_size)]
    
    # Process chunks concurrently with rate limiting
    semaphore = asyncio.Semaphore(max_concurrency)
    async with httpx.AsyncClient() as client:
        tasks = []
        for chunk in chunks:
            tasks.append(self._translate_chunk_async(client, semaphore, chunk, target_language, source_language))
        
        # Gather results maintaining original order
        chunk_results = await asyncio.gather(*tasks)
        
    # Flatten results
    return [translation for chunk in chunk_results for translation in chunk]
```

2. **Caching Strategy**: Implement a specialized cache for batch operations:

```python
def _get_cached_batch_results(self, texts, target_language, source_language):
    """Retrieve cached translations for batch items."""
    if not self.cache_enabled:
        return None, list(range(len(texts)))
        
    results = [None] * len(texts)
    missing_indices = []
    
    for i, text in enumerate(texts):
        cache_key = self._generate_cache_key(text, target_language, source_language)
        cached = self.cache.get(cache_key)
        if cached:
            results[i] = cached
        else:
            missing_indices.append(i)
            
    return results, missing_indices
```

### Monitoring and Metrics

Add detailed metrics collection for batch operations:

```python
def _update_batch_metrics(self, batch_size, successful_count, cached_count, error_count=0):
    """Update metrics specific to batch operations."""
    self.metrics['batch_requests'] += 1
    self.metrics['batch_total_texts'] += batch_size
    self.metrics['batch_successful_translations'] += successful_count
    self.metrics['batch_cached_translations'] += cached_count
    self.metrics['batch_failed_translations'] += error_count
    
    # Calculate and store efficiency metrics
    if batch_size > 0:
        efficiency = (successful_count / batch_size) * 100
        self.metrics['batch_efficiency_percent'] = efficiency
```

These enhancements provide a robust implementation for batch translation with proper error handling, performance optimization, and detailed metrics tracking.
</info added on 2025-05-04T17:55:28.479Z>

<info added on 2025-05-04T17:56:45.720Z>
<info added on 2025-05-05T09:12:36.481Z>
## Implementation Details for Language Detection

### Automatic Language Detection Implementation

When implementing the language detection feature, consider these technical aspects:

```python
def detect_language(self, text):
    """Detect the language of the provided text using DeepL's API."""
    if not text or not text.strip():
        self.logger.warning("Empty text provided for language detection")
        return None
        
    # DeepL doesn't have a dedicated language detection endpoint
    # Instead, we use a translation with null source language
    payload = [
        ('text', text),
        ('target_lang', 'EN')  # Use English as default target
    ]
    
    try:
        response = self._make_api_call_with_retry('POST', '/v2/translate', payload)
        data = response.json()
        
        if 'translations' in data and len(data['translations']) > 0:
            detected_lang = data['translations'][0].get('detected_source_language')
            if detected_lang:
                return detected_lang
                
        self.logger.error("Language detection failed: missing detected_source_language")
        return None
    except Exception as e:
        self.logger.error(f"Language detection error: {str(e)}")
        raise LanguageDetectionError(f"Failed to detect language: {str(e)}")
```

### Language Support Validation

Implement methods to check language support:

```python
def is_language_supported(self, language_code, as_source=True):
    """Check if a language is supported by DeepL API."""
    if as_source:
        return language_code.upper() in self.SUPPORTED_SOURCE_LANGUAGES
    else:
        return language_code.upper() in self.SUPPORTED_TARGET_LANGUAGES

def get_supported_languages(self, as_source=True):
    """Return list of supported language codes."""
    if as_source:
        return list(self.SUPPORTED_SOURCE_LANGUAGES)
    else:
        return list(self.SUPPORTED_TARGET_LANGUAGES)
```

### Caching Implementation for Batch Operations

Implement an efficient caching strategy for batch operations:

```python
def _apply_batch_caching(self, texts, target_language, source_language=None):
    """Apply caching to batch translation requests."""
    if not self.cache_enabled:
        return None, texts
        
    # Initialize results with None placeholders
    results = [None] * len(texts)
    texts_to_translate = []
    indices_map = []
    
    # Check cache for each text
    for i, text in enumerate(texts):
        cache_key = self._generate_cache_key(text, target_language, source_language)
        cached_result = self.cache.get(cache_key)
        
        if cached_result:
            results[i] = cached_result
            self.metrics['cache_hits'] += 1
        else:
            texts_to_translate.append(text)
            indices_map.append(i)
            self.metrics['cache_misses'] += 1
    
    return results, texts_to_translate, indices_map
```

### Usage Statistics Implementation

Add comprehensive usage tracking:

```python
class UsageStatistics:
    def __init__(self):
        self.character_count = 0
        self.request_count = 0
        self.batch_request_count = 0
        self.total_texts_processed = 0
        self.cache_hit_count = 0
        self.cache_hit_characters = 0
        self.api_errors = 0
        self.last_reset = datetime.now()
        
    def reset(self):
        """Reset all statistics."""
        self.__init__()
        
    def to_dict(self):
        """Convert statistics to dictionary."""
        return {
            'character_count': self.character_count,
            'request_count': self.request_count,
            'batch_request_count': self.batch_request_count,
            'total_texts_processed': self.total_texts_processed,
            'cache_hit_rate': self._calculate_cache_hit_rate(),
            'character_savings': self._calculate_character_savings(),
            'api_errors': self.api_errors,
            'tracking_since': self.last_reset.isoformat()
        }
        
    def _calculate_cache_hit_rate(self):
        total = self.cache_hit_count + self.total_texts_processed
        if total == 0:
            return 0
        return (self.cache_hit_count / total) * 100
        
    def _calculate_character_savings(self):
        if self.character_count == 0 and self.cache_hit_characters == 0:
            return 0
        total = self.character_count + self.cache_hit_characters
        return (self.cache_hit_characters / total) * 100 if total > 0 else 0
```

### Integration Testing Considerations

When testing the batch translation and language detection features:

1. Create mock responses that include the `detected_source_language` field
2. Test with mixed language inputs to verify detection accuracy
3. Test with edge cases like very short texts where detection may be less reliable
4. Verify that batch translation with automatic detection correctly handles texts in different languages

```python
def test_batch_translation_with_auto_detection(self):
    """Test batch translation with automatic language detection."""
    texts = ["Hello world", "Bonjour le monde", "Hallo Welt"]
    mock_response = {
        "translations": [
            {"text": "Hola mundo", "detected_source_language": "EN"},
            {"text": "Hola mundo", "detected_source_language": "FR"},
            {"text": "Hola mundo", "detected_source_language": "DE"}
        ]
    }
    
    with patch.object(self.service, '_make_api_call_with_retry') as mock_api:
        mock_api.return_value.json.return_value = mock_response
        mock_api.return_value.status_code = 200
        
        result = self.service.translate_batch(texts, "ES")
        
        # Verify API was called with null source_language
        args, kwargs = mock_api.call_args
        payload = kwargs.get('data', [])
        self.assertNotIn(('source_lang', ANY), payload)
```
</info added on 2025-05-05T09:12:36.481Z>
</info added on 2025-05-04T17:56:45.720Z>

