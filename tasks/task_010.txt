# Task ID: 10
# Title: Implement Markdown reconstruction from translated segments
# Status: done
# Dependencies: 7, 8
# Priority: high
# Description: Create functionality to rebuild Markdown content using translated text segments.
# Details:
Extend MarkdownProcessor to replace original text segments in the AST with translated segments based on the mapping created during extraction. Implement methods to reconstruct the full Markdown content from the modified AST. Ensure all formatting, links, and non-translated elements are preserved correctly. Note that the current implementation has a known limitation: it replaces entire inline segments without preserving inline formatting (bold, italic, links within text). This limitation will be addressed when subtask 10.4 is completed.

# Test Strategy:
Create a test workflow with extraction, simulated translation, and reconstruction. Compare the reconstructed Markdown with expected output to verify structure preservation. Test with complex Markdown features. Be aware that tests involving inline formatting will not pass until subtask 10.4 is completed.

# Subtasks:
## 1. Create AST node replacement method [done]
### Dependencies: None
### Description: Implement a method in MarkdownProcessor that can replace text content in AST nodes while preserving node structure and attributes
### Details:
Create a method called `replaceNodeContent(node, originalText, translatedText)` that takes an AST node, the original text, and the translated text as parameters. The method should update the node's content with the translated text while preserving all node attributes, formatting, and structure. Handle different node types (paragraph, heading, list item, etc.) appropriately. Include unit tests to verify the method works correctly for various node types.

<info added on 2025-05-04T18:13:45.543Z>
## Implementation Plan (Subtask 10.1 - TDD Approach)

### Implementation Details:

1. **Token Structure Handling:**
   - The markdown-it-py parser creates tokens with a specific structure:
   - Paragraph tokens have `type: 'paragraph_open'` followed by an `inline` token containing children, then `paragraph_close`
   - The actual text content is in `text` type children within the `inline` token

2. **Method Signature:**
   ```python
   def replace_node_content(self, token: Dict[str, Any], translated_text: str) -> bool:
       """
       Replace the content of the first text child within an inline token.
       
       Args:
           token: The inline token containing text to replace
           translated_text: The new text content
           
       Returns:
           bool: True if replacement succeeded, False otherwise
       """
   ```

3. **Error Handling:**
   - Add specific error messages:
     ```python
     if token.get('type') != 'inline':
         self.logger.error(f"Expected inline token, got {token.get('type')}")
         return False
     
     if not token.get('children'):
         self.logger.warning("Token has no children")
         return False
     ```

4. **Test Data Examples:**
   ```python
   # Test data for paragraph
   md_text = "This is a paragraph."
   tokens = self.processor.parse(md_text)
   inline_token = tokens[1]  # The inline token is typically at index 1
   
   # Test data for heading
   md_heading = "# This is a heading"
   heading_tokens = self.processor.parse(md_heading)
   heading_inline = heading_tokens[1]
   ```

5. **Edge Cases to Test:**
   - Empty text content
   - Inline tokens with multiple text children (should only replace first)
   - Tokens with mixed formatting (should preserve formatting tokens)
   - Unicode/special characters in translated text

6. **Logging Recommendations:**
   - Add debug logging showing before/after content for traceability
   - Log token structure at trace level for debugging complex cases
</info added on 2025-05-04T18:13:45.543Z>

<info added on 2025-05-04T18:47:05.446Z>
## Implementation Update (Subtask 10.1 - Integration Details)

### Current Implementation Status:
```python
def replace_node_content(self, token: Dict[str, Any], translated_text: str) -> bool:
    """
    Replace the content of the first text child within an inline token.
    
    Args:
        token: The inline token containing text to replace
        translated_text: The new text content
        
    Returns:
        bool: True if replacement succeeded, False otherwise
    """
    if token.get('type') != 'inline':
        self.logger.error(f"Expected inline token, got {token.get('type')}")
        return False
    
    text_child = None
    for child in token.get('children', []):
        if child.get('type') == 'text':
            text_child = child
            break
    
    if not text_child:
        self.logger.warning("No text child found in token")
        return False
    
    # Store original for logging
    original_content = text_child.get('content', '')
    
    # Replace content
    text_child['content'] = translated_text
    
    # Remove other children to avoid duplicating content
    # This is a simplification - we'll handle complex formatting in later subtasks
    token['children'] = [text_child]
    
    self.logger.debug(f"Replaced: '{original_content}' â†’ '{translated_text}'")
    return True
```

### Integration with Reassembly Process:
```python
def reassemble_markdown(self, tokens: List[Dict], translations: Dict[str, str]) -> str:
    """
    Reassemble markdown with translations applied to appropriate tokens.
    
    Args:
        tokens: The parsed markdown tokens
        translations: Dictionary mapping original text to translated text
        
    Returns:
        str: Reassembled markdown with translations
    """
    # Create a deep copy to avoid modifying original tokens
    tokens_copy = copy.deepcopy(tokens)
    
    # Track which translations have been applied
    applied_translations = set()
    
    # Process tokens
    for i, token in enumerate(tokens_copy):
        if token.get('type') == 'inline':
            for child in token.get('children', []):
                if child.get('type') == 'text':
                    original_text = child.get('content', '')
                    if original_text in translations:
                        self.replace_node_content(token, translations[original_text])
                        applied_translations.add(original_text)
                        break
    
    # Log any unused translations
    unused = set(translations.keys()) - applied_translations
    if unused:
        self.logger.warning(f"Unused translations: {len(unused)}")
    
    # Render back to markdown
    return self.renderer.render(tokens_copy)
```

### Known Limitations:
1. Only replaces the first text child in an inline token
2. Removes additional children, which means inline formatting (bold, italic) is lost
3. Does not handle complex nested structures like lists within lists

### Next Steps:
1. Enhance to preserve inline formatting by manipulating the AST more carefully
2. Add support for handling complex nested structures
3. Implement a more robust token path tracking system for precise replacements
</info added on 2025-05-04T18:47:05.446Z>

## 2. Implement segment mapping lookup functionality [done]
### Dependencies: 10.1
### Description: Create a mechanism to efficiently look up translated segments based on original text and node context
### Details:
Implement a `SegmentMapper` class that manages the mapping between original text segments and their translations. Include methods like `getTranslationForSegment(originalText, nodeContext)` that retrieves the appropriate translation based on the original text and contextual information about the node (like node type, position, etc.). This will handle cases where the same text might have different translations in different contexts. Add appropriate caching to optimize performance for repeated lookups.

## 3. Develop AST traversal and modification algorithm [done]
### Dependencies: 10.1, 10.2
### Description: Create a recursive algorithm to traverse the Markdown AST and apply translations to each text node
### Details:
Implement a method called `traverseAndTranslateAST(ast, segmentMapper)` that recursively walks through the AST, identifies text nodes that need translation, and applies the appropriate translations using the segment mapper and node replacement method. The algorithm should handle nested structures correctly and maintain the hierarchical relationships between nodes. Include special handling for nodes that should not be modified (like code blocks or already processed custom elements).

## 4. Implement special element preservation logic [done]
### Dependencies: 10.3
### Description: Create handlers for preserving special Markdown elements like links, images, and formatting during reconstruction
### Details:
Extend the AST traversal algorithm with specialized handlers for complex Markdown elements. Implement methods like `preserveLinks(node)`, `preserveImages(node)`, and `preserveFormatting(node)` that ensure these elements are correctly maintained during translation. For links, ensure the link text is translated while the URL is preserved. For images, translate alt text while preserving the image path. For formatting (bold, italic, etc.), ensure the formatting markers are correctly applied to the translated text.

NOTE: This subtask has been deferred to complete the core block-level reconstruction functionality first. The current implementation replaces entire inline segments, meaning inline formatting (bold, italic, links within text) is NOT preserved in the translated output. This limitation must be addressed before any downstream tasks that rely on perfect inline formatting fidelity in the generated translated Markdown files.

## 5. Create Markdown reconstruction method [done]
### Dependencies: 10.3, 10.4
### Description: Implement functionality to convert the modified AST back into valid Markdown text
### Details:
Create a method called `reconstructMarkdown(ast)` that takes the modified AST and generates valid Markdown text. This should handle all Markdown syntax elements correctly, including headings, lists, code blocks, tables, and formatting. Ensure proper indentation and line breaks are maintained. The method should produce Markdown that is semantically equivalent to the original but with translated text segments.

## 6. Add integration and validation functionality [done]
### Dependencies: 10.5
### Description: Implement methods to validate the reconstructed Markdown and integrate the entire translation process
### Details:
Create a `validateReconstructedMarkdown(original, translated)` method that checks the structural integrity of the translated Markdown compared to the original. Implement the main public method `translateMarkdown(markdown, translations)` that orchestrates the entire process: parsing the original Markdown to AST, applying translations, reconstructing the Markdown, and validating the result. Add comprehensive error handling and logging to identify and report any issues during the translation process. Include integration tests that verify the entire workflow with various Markdown structures and translation scenarios.

<info added on 2025-05-04T18:48:46.223Z>
## Implementation Details for Integration and Validation

### `validateReconstructedMarkdown` Implementation:

```python
def validateReconstructedMarkdown(self, original_markdown: str, reconstructed_markdown: str) -> bool:
    """
    Validates the structural integrity of translated Markdown compared to original.
    
    Args:
        original_markdown: The source Markdown text
        reconstructed_markdown: The translated Markdown text
        
    Returns:
        bool: True if validation passes, False otherwise
    """
    try:
        # Basic validation: ensure the translated content can be parsed
        translated_ast = self.parse(reconstructed_markdown)
        
        # Structure validation: compare node types and hierarchy
        original_ast = self.parse(original_markdown)
        
        # Compare structure (not content) of both ASTs
        if not self._compare_ast_structure(original_ast, translated_ast):
            self.logger.warning("Structural mismatch between original and translated Markdown")
            return False
            
        return True
    except Exception as e:
        self.logger.error(f"Validation failed: {str(e)}")
        return False
        
def _compare_ast_structure(self, original_node, translated_node):
    """
    Recursively compares the structure of two AST nodes.
    Only compares node types and hierarchy, not content.
    
    Returns:
        bool: True if structures match, False otherwise
    """
    if original_node['type'] != translated_node['type']:
        return False
        
    # Check if both have children or neither has children
    orig_children = original_node.get('children', [])
    trans_children = translated_node.get('children', [])
    
    if len(orig_children) != len(trans_children):
        return False
        
    # Recursively check children
    for i in range(len(orig_children)):
        if not self._compare_ast_structure(orig_children[i], trans_children[i]):
            return False
            
    return True
```

### Error Handling in `translateMarkdown`:

```python
def translateMarkdown(self, markdown_text: str, translations: Dict[str, str]) -> str:
    """
    Orchestrates the entire Markdown translation process.
    
    Args:
        markdown_text: Original Markdown content
        translations: Dictionary mapping original text to translated text
        
    Returns:
        str: Translated Markdown content
        
    Raises:
        MarkdownProcessingError: If translation process fails
    """
    try:
        # Parse the original Markdown to AST
        self.logger.info("Parsing original Markdown to AST")
        original_ast = self.parse(markdown_text)
        
        # Apply translations and reconstruct
        self.logger.info(f"Applying {len(translations)} translations")
        reconstructed_markdown = self.reassemble_markdown(original_ast, translations)
        
        # Validate the result
        self.logger.info("Validating reconstructed Markdown")
        if not self.validateReconstructedMarkdown(markdown_text, reconstructed_markdown):
            self.logger.warning("Validation warnings occurred but translation completed")
        
        return reconstructed_markdown
        
    except Exception as e:
        error_msg = f"Markdown translation failed: {str(e)}"
        self.logger.error(error_msg)
        raise MarkdownProcessingError(error_msg) from e
```

### Integration Test Example:

```python
def test_end_to_end_translation_process():
    """Tests the complete Markdown translation workflow with various structures"""
    processor = MarkdownProcessor()
    
    # Test case with multiple Markdown elements
    original_markdown = """
# Hello World

This is a paragraph with **bold** and *italic* text.

- List item 1
- List item 2

| Header 1 | Header 2 |
|----------|----------|
| Cell 1   | Cell 2   |
"""

    translations = {
        "Hello World": "Bonjour le Monde",
        "This is a paragraph with": "C'est un paragraphe avec",
        "bold": "gras",
        "italic": "italique",
        "text": "texte",
        "List item 1": "Ã‰lÃ©ment de liste 1",
        "List item 2": "Ã‰lÃ©ment de liste 2",
        "Header 1": "En-tÃªte 1",
        "Header 2": "En-tÃªte 2",
        "Cell 1": "Cellule 1",
        "Cell 2": "Cellule 2"
    }
    
    expected_contains = [
        "# Bonjour le Monde",
        "C'est un paragraphe avec **gras** et *italique* texte",
        "- Ã‰lÃ©ment de liste 1",
        "- Ã‰lÃ©ment de liste 2",
        "| En-tÃªte 1 | En-tÃªte 2 |",
        "| Cellule 1 | Cellule 2 |"
    ]
    
    result = processor.translateMarkdown(original_markdown, translations)
    
    # Verify all expected content is in the result
    for expected in expected_contains:
        assert expected in result, f"Expected '{expected}' not found in result"
```

### Custom Exception Class:

```python
class MarkdownProcessingError(Exception):
    """Exception raised for errors in the Markdown processing pipeline."""
    pass
```
</info added on 2025-05-04T18:48:46.223Z>

## 7. Document inline formatting limitations [done]
### Dependencies: 10.6
### Description: Document the current limitations regarding inline formatting preservation in the translated output
### Details:
Create comprehensive documentation that clearly explains the current limitations of the Markdown reconstruction process with respect to inline formatting. Document that the current implementation replaces entire inline segments and does not preserve inline formatting elements like bold, italic, and links within text. Include examples showing what works and what doesn't work in the current implementation. Add warnings in code comments and user-facing documentation to ensure developers and users are aware of these limitations until subtask 10.4 is completed.

## 8. Create test cases for inline formatting preservation [done]
### Dependencies: 10.7
### Description: Develop test cases that will validate inline formatting preservation once subtask 10.4 is implemented
### Details:
Create a comprehensive set of test cases that specifically target inline formatting preservation. These tests should include various combinations of bold, italic, links, code spans, and other inline elements within translated text. The tests should be designed to fail with the current implementation but pass once subtask 10.4 is completed. Include detailed comments explaining the expected behavior and why the current implementation doesn't meet these requirements. These tests will serve as validation criteria for the completion of subtask 10.4.

