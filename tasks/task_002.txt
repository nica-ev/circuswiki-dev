# Task ID: 2
# Title: Implement ConfigLoader component
# Status: done
# Dependencies: 1
# Priority: high
# Description: Create a component to load and validate configuration from settings.txt and translate.env files.
# Details:
Implement a ConfigLoader class that reads settings.txt for INPUT_DIR, OUTPUT_DIR, TARGET_LANGUAGES, YAML_TRANSLATE_FIELDS, API_PROVIDER, TEST_MODE. Use python-dotenv to read translate.env for API keys (e.g., DEEPL_API_KEY). Include validation for required fields and appropriate error handling for missing or invalid configuration.

# Test Strategy:
Create test configuration files with valid and invalid settings. Verify ConfigLoader correctly loads settings, validates required fields, and raises appropriate exceptions for invalid configurations.

# Subtasks:
## 1. Create ConfigLoader class skeleton with file path handling [done]
### Dependencies: None
### Description: Set up the basic structure of the ConfigLoader class with initialization and file path handling for both configuration files.
### Details:
Create a new file `config_loader.py` with a ConfigLoader class. Implement the `__init__` method that accepts optional paths to settings.txt and translate.env files (with defaults). Add methods to validate file existence and readability. Include basic exception handling for file access issues and implement logging setup.

<info added on 2025-05-04T00:52:33.012Z>
```python
# Implementation details for config_loader.py

import os
import logging
from pathlib import Path
from typing import Optional, Dict, Any

class ConfigError(Exception):
    """Base exception for configuration errors."""
    pass

class ConfigFileNotFoundError(ConfigError):
    """Raised when a configuration file cannot be found."""
    pass

class ConfigFileNotReadableError(ConfigError):
    """Raised when a configuration file exists but cannot be read."""
    pass

class ConfigLoader:
    def __init__(self, settings_path: Optional[str] = None, env_path: Optional[str] = None):
        # Get the directory where this script is located
        base_dir = Path(__file__).parent.parent
        
        # Set default paths relative to the project root
        self.settings_file = Path(settings_path or base_dir / "config" / "settings.txt").resolve()
        self.env_file = Path(env_path or base_dir / "config" / "translate.env").resolve()
        
        # Initialize empty configuration dictionaries
        self.settings: Dict[str, Any] = {}
        self.env_vars: Dict[str, str] = {}
        
        # Set up logging
        self.logger = logging.getLogger(__name__)
        
        # Validate configuration files
        try:
            self._validate_file(self.settings_file)
            self._validate_file(self.env_file)
            self.logger.info(f"Configuration files validated successfully")
        except ConfigError as e:
            self.logger.error(f"Configuration error: {str(e)}")
            raise
    
    def _validate_file(self, file_path: Path) -> None:
        """
        Validate that a configuration file exists and is readable.
        
        Args:
            file_path: Path to the configuration file
            
        Raises:
            ConfigFileNotFoundError: If the file doesn't exist
            ConfigFileNotReadableError: If the file exists but can't be read
        """
        self.logger.debug(f"Validating configuration file: {file_path}")
        
        if not file_path.exists():
            self.logger.error(f"Configuration file not found: {file_path}")
            raise ConfigFileNotFoundError(f"Configuration file not found: {file_path}")
        
        if not file_path.is_file():
            self.logger.error(f"Path exists but is not a file: {file_path}")
            raise ConfigFileNotFoundError(f"Path exists but is not a file: {file_path}")
        
        if not os.access(file_path, os.R_OK):
            self.logger.error(f"Configuration file not readable: {file_path}")
            raise ConfigFileNotReadableError(f"Configuration file not readable: {file_path}")
```
</info added on 2025-05-04T00:52:33.012Z>

## 2. Implement settings.txt parser [done]
### Dependencies: 2.1
### Description: Create functionality to read and parse the settings.txt file for configuration parameters.
### Details:
Add a method `_parse_settings_file()` that reads the settings.txt file and extracts the required configuration parameters (INPUT_DIR, OUTPUT_DIR, TARGET_LANGUAGES, YAML_TRANSLATE_FIELDS, API_PROVIDER, TEST_MODE). Parse each line using appropriate string manipulation (e.g., splitting by '=' and stripping whitespace). Store the parsed values in a dictionary attribute. Handle comments and empty lines appropriately.

<info added on 2025-05-04T00:59:53.262Z>
The implementation in `translation-py/src/config_loader.py` should handle several edge cases:

1. Type conversion for specific settings:
   - Convert `TARGET_LANGUAGES` from comma-separated string to a list
   - Convert `YAML_TRANSLATE_FIELDS` from comma-separated string to a list
   - Convert `TEST_MODE` string to boolean value

2. Default values for optional parameters:
   - Set `TEST_MODE=False` if not specified
   - Use current directory for `INPUT_DIR` or `OUTPUT_DIR` if missing

3. Validation logic:
   - Check that required parameters exist after parsing
   - Verify that directories in `INPUT_DIR` and `OUTPUT_DIR` are valid paths

Example implementation snippet:
```python
def _parse_settings_file(self):
    self.settings = {}
    try:
        with open(self.settings_path, 'r', encoding='utf-8') as file:
            for line in file:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                    
                try:
                    key, value = [part.strip() for part in line.split('=', 1)]
                    
                    # Type conversions
                    if key in ['TARGET_LANGUAGES', 'YAML_TRANSLATE_FIELDS']:
                        value = [item.strip() for item in value.split(',') if item.strip()]
                    elif key == 'TEST_MODE':
                        value = value.lower() in ['true', 'yes', '1']
                        
                    self.settings[key] = value
                except ValueError:
                    self.logger.warning(f"Skipping invalid line in settings file: {line}")
        
        # Apply defaults
        self.settings.setdefault('TEST_MODE', False)
        self.settings.setdefault('INPUT_DIR', os.getcwd())
        self.settings.setdefault('OUTPUT_DIR', os.getcwd())
        
        # Validate required settings
        self._validate_settings()
    except OSError as e:
        raise ConfigError(f"Failed to read settings file: {e}")
```
</info added on 2025-05-04T00:59:53.262Z>

## 3. Implement environment variable loading with python-dotenv [done]
### Dependencies: 2.1
### Description: Add functionality to load API keys from translate.env using python-dotenv.
### Details:
Use python-dotenv to load environment variables from the translate.env file. Add a method `_load_env_variables()` that reads API keys (e.g., DEEPL_API_KEY) from the environment file. Store these values in a separate dictionary attribute. Include error handling for missing or inaccessible environment files.

<info added on 2025-05-04T01:03:38.876Z>
```python
# Implementation details for _load_env_variables method:
def _load_env_variables(self):
    """Load environment variables from translate.env file."""
    import os
    from dotenv import load_dotenv
    
    try:
        # Check if env file exists
        if os.path.exists(self.env_file):
            # Load environment variables from file
            load_dotenv(dotenv_path=self.env_file, override=False)
            self.logger.info(f"Environment variables loaded from {self.env_file}")
            
            # Store API keys in dictionary for easy access
            self.env_vars = {
                'DEEPL_API_KEY': os.getenv('DEEPL_API_KEY'),
                'GOOGLE_API_KEY': os.getenv('GOOGLE_API_KEY'),
                'AZURE_API_KEY': os.getenv('AZURE_API_KEY'),
                'AZURE_REGION': os.getenv('AZURE_REGION')
            }
            
            # Filter out None values
            self.env_vars = {k: v for k, v in self.env_vars.items() if v is not None}
            
            if not self.env_vars:
                self.logger.warning("No API keys found in environment file")
        else:
            self.logger.warning(f"Environment file {self.env_file} not found")
            self.env_vars = {}
    except Exception as e:
        self.logger.error(f"Error loading environment variables: {str(e)}")
        self.env_vars = {}
```

Add this method to the ConfigLoader class and update the `__init__` method to call `self._load_env_variables()` after initializing the env_file path. This implementation provides proper error handling and stores API keys in a dedicated dictionary for convenient access throughout the application.
</info added on 2025-05-04T01:03:38.876Z>

## 4. Implement configuration validation [done]
### Dependencies: 2.2, 2.3
### Description: Add validation logic to ensure all required configuration parameters are present and valid.
### Details:
Create a `validate_config()` method that checks if all required fields are present and have valid values. Define validation rules for each parameter (e.g., directories should exist or be creatable, TARGET_LANGUAGES should be a comma-separated list, API_PROVIDER should be one of the supported options). Implement type checking and format validation for each field. Raise specific exceptions with clear error messages for validation failures.

<info added on 2025-05-04T01:05:31.628Z>
```python
def _validate_config(self):
    """Validates configuration parameters and raises ConfigValidationError if invalid."""
    # Check required settings
    required_settings = ['INPUT_DIR', 'OUTPUT_DIR', 'TARGET_LANGUAGES', 'API_PROVIDER']
    missing = [setting for setting in required_settings if not self.settings.get(setting)]
    if missing:
        raise ConfigValidationError(f"Missing required settings: {', '.join(missing)}")
    
    # Validate directories
    for dir_setting in ['INPUT_DIR', 'OUTPUT_DIR']:
        path = Path(self.settings[dir_setting])
        if not path.exists():
            try:
                path.mkdir(parents=True)
                logger.info(f"Created directory: {path}")
            except Exception as e:
                raise ConfigValidationError(f"Cannot create {dir_setting} directory: {str(e)}")
    
    # Validate target languages
    if not self.settings['TARGET_LANGUAGES'].strip():
        raise ConfigValidationError("TARGET_LANGUAGES cannot be empty")
    self.settings['TARGET_LANGUAGES_LIST'] = [
        lang.strip() for lang in self.settings['TARGET_LANGUAGES'].split(',')
    ]
    
    # Validate API provider
    allowed_providers = ['DeepL', 'Google', 'Azure']
    if self.settings['API_PROVIDER'] not in allowed_providers:
        raise ConfigValidationError(
            f"API_PROVIDER must be one of: {', '.join(allowed_providers)}"
        )
    
    # Process TEST_MODE
    test_mode = self.settings.get('TEST_MODE', 'false').lower()
    self.settings['TEST_MODE_BOOL'] = test_mode in ['true', '1', 'yes']
    
    # Validate YAML_TRANSLATE_FIELDS if present
    if 'YAML_TRANSLATE_FIELDS' in self.settings and not self.settings['YAML_TRANSLATE_FIELDS'].strip():
        raise ConfigValidationError("YAML_TRANSLATE_FIELDS cannot be empty if specified")
    
    # Check for API keys when not in test mode
    if not self.settings['TEST_MODE_BOOL']:
        api_key_map = {
            'DeepL': 'DEEPL_API_KEY',
            'Google': 'GOOGLE_CLOUD_KEY',
            'Azure': 'MICROSOFT_TRANSLATOR_KEY'
        }
        required_key = api_key_map[self.settings['API_PROVIDER']]
        if not self.env_vars.get(required_key):
            raise ConfigValidationError(f"Missing required API key: {required_key}")

class ConfigValidationError(Exception):
    """Exception raised for configuration validation errors."""
    pass
```
</info added on 2025-05-04T01:05:31.628Z>

## 5. Create public interface and documentation [done]
### Dependencies: 2.4
### Description: Implement public methods to access configuration and add comprehensive documentation.
### Details:
Create public getter methods to access validated configuration parameters (e.g., `get_input_dir()`, `get_target_languages()`, `get_api_key()`). Implement a `load_config()` method that orchestrates the entire loading and validation process. Add comprehensive docstrings following a standard format (e.g., Google style) for the class and all methods. Include usage examples in the module docstring. Add type hints to all methods and parameters.

